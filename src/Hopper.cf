--
-- Layout
-- ======
-- Inserts "{" "}" around definition after the keywords below

layout "=", "::", "of" ;
layout toplevel        ;

--
-- Module
-- ======
--

entrypoints Module;
MMod. Module ::= "module" IdCon Exports "where" ";" [Def] ;

--
-- Exports
-- =======
-- NEmpty allows leaving the () out

NEmpty. Exports ::=                  ;
NExps.  Exports ::= "(" [Export] ")" ;

NExp. Export ::= IdVar ;
separator Export ","   ;

--
-- Definitions
-- ===========
-- Moved out definitions to make them more flexible and reuseable

DFun.  Def ::= Func ;
DSig.  Def ::= Sign ;
DAdt.  Def ::= Adt  ;
separator Def ";"   ;

--
-- Functions
-- =========
--

FFun. Func ::= IdVar [Arg] "=" "{" Expr "}" ;

--
-- Arguments
-- =========
-- If ArgTuple has one element, treat it as parenthethis
-- Extra Arg in ArCon is to fix a reduce/reduce error
-- Arg and Pat are the same now. Merge? 

AId.    Arg ::= Id                 ;  
APrim.  Arg ::= Prim               ;
AWild.  Arg ::= "_"                ;
ATuple. Arg ::= "(" [ArgTuple] ")" ;
terminator Arg ""                  ;

ArCon. ArgTuple ::= IdCon Arg [Arg] ; 
ArArg. ArgTuple ::= Arg             ;
separator ArgTuple ","              ;

--
-- Expressions
-- ===========
-- Renamed from Exp to Expr to remove name clash with Prelude

EId.      Expr2 ::= Id                                   ;
EPrim.    Expr2 ::= Prim                                 ;
EOpr.     Expr2 ::= "(" IdOpr ")"                        ;
EInfix.   Expr1 ::= Expr1 IdOpr Expr2                    ;
EApp.     Expr1 ::= Expr1 Expr2                          ;
ECase.    Expr1 ::= "case" Expr1 "of" "{" [Clause] "}"   ;
EIf.      Expr1 ::= "if" Expr1 "then" Expr2 "else" Expr2 ;
ELambda.  Expr  ::= "\\" [Pat] "->" Expr                 ;
coercions Expr 2                                         ;

CClause. Clause ::= Pat "->" Expr;
separator nonempty Cla ";";

--
-- Patterns
-- ========
-- Extra Pat in PaCon is to fix a reduce/reduce error
-- Arg and Pat are the same now. Merge? 

PId.    Pat ::= Id                 ;
PPrim.  Pat ::= Prim               ;
PWild.  Pat ::= "_"                ;
PTuple. Pat ::= "(" [PatTuple] ")" ;
terminator nonempty Pat ""         ;

PaCon. PatTuple ::= IdCon Pat [Pat] ;
PaPat. PatTuple ::= Pat             ;
separator PatTuple ","              ;

--
-- Signatures
-- ==========
--

SSig. Sign ::= IdVar "::" "{" [Type] "}" ;

--
-- Types
-- =====
-- If TypeTuple has one element, treat it as parenthethis
-- Replace TName and TVar with TId ::= Id ?

TName.  Type ::= IdCon [Id]          ;
TVar.   Type ::= IdVar [Id]          ;
TTuple. Type ::= "(" [TypeTuple] ")" ;
separator nonempty Type "->"         ;

TyTuple. TypeTuple ::= [Type] ;
separator TypeTuple ","       ;

--
-- ADT declarations
-- ================
-- 

--TODO: Parenteser och tuples
AAdt. Adt ::= "data" IdCon [AdtVar] "=" "{" [Cons] "}" ;

AdVar. AdtVar ::= IdVar ;
terminator AdtVar ""    ;

AdCon. Cons ::= IdCon [Id]  ;
separator nonempty Cons "|" ;

--
-- Identifiers and primitives
-- ==========================
-- To simplify lists without any separators
-- maybe should do this for int, char, string ect...

ICon. Id ::= IdCon ;
IVar. Id ::= IdVar ;
terminator Id ""   ;

IInteger. Prim ::= Integer ;
IDouble.  Prim ::= Double  ;
IString.  Prim ::= String  ;
IChar.    Prim ::= Char    ;

--
-- Tokens
-- ======
-- IdVar: identifier starting with a lower letter
-- IdCon: starting with a upper letter
-- IdOpr: operators

token IdVar (lower (digit | letter | '_' )* ) ; 
token IdCon (upper (digit | letter)* )        ;
token IdOpr ( [ ".:-^*+=<>&%$!#%|/\\" ]+ )    ;

--
-- Comments 
-- ========
-- Can't handle nested comments, bug in bnfc

comment "--"      ;
comment "{-" "-}" ;
