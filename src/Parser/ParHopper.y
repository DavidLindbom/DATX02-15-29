-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.ParHopper where
import Parser.AbsHopper
import Parser.LexHopper
import Parser.ErrM

}

%name pModule Module

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  '->' { PT _ (TS _ 4) }
  ': (' { PT _ (TS _ 5) }
  '::' { PT _ (TS _ 6) }
  ';' { PT _ (TS _ 7) }
  '=' { PT _ (TS _ 8) }
  '\\' { PT _ (TS _ 9) }
  '_' { PT _ (TS _ 10) }
  'module' { PT _ (TS _ 11) }
  'where' { PT _ (TS _ 12) }
  '{' { PT _ (TS _ 13) }
  '}' { PT _ (TS _ 14) }

L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_IdVar { PT _ (T_IdVar $$) }
L_IdCon { PT _ (T_IdCon $$) }
L_IdOpr { PT _ (T_IdOpr $$) }


%%

String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
IdVar    :: { IdVar} : L_IdVar { IdVar ($1)}
IdCon    :: { IdCon} : L_IdCon { IdCon ($1)}
IdOpr    :: { IdOpr} : L_IdOpr { IdOpr ($1)}

Module :: { Module }
Module : 'module' IdCon '(' ListExport ')' 'where' ';' ListDef { MModule $2 $4 $8 } 


Export :: { Export }
Export : IdVar { MExport $1 } 


ListExport :: { [Export] }
ListExport : Export { (:[]) $1 } 
  | Export ',' ListExport { (:) $1 $3 }


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | Def { (:[]) $1 }
  | Def ';' ListDef { (:) $1 $3 }


Def :: { Def }
Def : IdVar '::' ListType { DSig $1 $3 } 
  | IdVar '=' '{' Exp '}' { DFun $1 $4 }


Type :: { Type }
Type : IdCon { TName $1 } 
  | IdVar { TVar $1 }
  | '(' Type '->' ListType ')' { TFun $2 $4 }


ListType :: { [Type] }
ListType : Type { (:[]) $1 } 
  | Type '->' ListType { (:) $1 $3 }


Exp2 :: { Exp }
Exp2 : IdVar { EVar $1 } 
  | IdCon { ECon $1 }
  | '(' IdOpr ')' { EOpr $2 }
  | String { EString $1 }
  | Char { EChar $1 }
  | Integer { EInteger $1 }
  | Double { EDouble $1 }
  | '(' Exp ')' { $2 }


Exp1 :: { Exp }
Exp1 : Exp1 IdOpr Exp2 { EInfix $1 $2 $3 } 
  | Exp1 Exp2 { EApp $1 $2 }
  | Exp2 { $1 }


Exp :: { Exp }
Exp : '\\' ListPat '->' Exp { ELambda $2 $4 } 
  | Exp1 { $1 }


Pat :: { Pat }
Pat : IdCon { PCon $1 } 
  | IdVar { PVar $1 }
  | '_' { PWild }


ListPat :: { [Pat] }
ListPat : Pat { (:[]) $1 } 
  | Pat ListPat { (:) $1 $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

