-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.ParHopper where
import Parser.AbsHopper
import Parser.LexHopper
import Utils.ErrM

}

%name pModule Module

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  '->' { PT _ (TS _ 4) }
  '::' { PT _ (TS _ 5) }
  ';' { PT _ (TS _ 6) }
  '=' { PT _ (TS _ 7) }
  '\\' { PT _ (TS _ 8) }
  '_' { PT _ (TS _ 9) }
  'case' { PT _ (TS _ 10) }
  'data' { PT _ (TS _ 11) }
  'else' { PT _ (TS _ 12) }
  'if' { PT _ (TS _ 13) }
  'module' { PT _ (TS _ 14) }
  'of' { PT _ (TS _ 15) }
  'then' { PT _ (TS _ 16) }
  'where' { PT _ (TS _ 17) }
  '{' { PT _ (TS _ 18) }
  '|' { PT _ (TS _ 19) }
  '}' { PT _ (TS _ 20) }

L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_IdVar { PT _ (T_IdVar $$) }
L_IdCon { PT _ (T_IdCon $$) }
L_IdOpr { PT _ (T_IdOpr $$) }


%%

String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
IdVar    :: { IdVar} : L_IdVar { IdVar ($1)}
IdCon    :: { IdCon} : L_IdCon { IdCon ($1)}
IdOpr    :: { IdOpr} : L_IdOpr { IdOpr ($1)}

Module :: { Module }
Module : 'module' IdCon '(' ListExport ')' 'where' ';' ListDef { MModule $2 $4 $8 } 


Export :: { Export }
Export : IdVar { MExport $1 } 


ListExport :: { [Export] }
ListExport : {- empty -} { [] } 
  | Export { (:[]) $1 }
  | Export ',' ListExport { (:) $1 $3 }


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | Def { (:[]) $1 }
  | Def ';' ListDef { (:) $1 $3 }


Def :: { Def }
Def : IdVar '::' ListType { DSig $1 $3 } 
  | IdVar ListArg '=' '{' Exp '}' { DFun $1 $2 $5 }
  | 'data' IdCon '=' '{' ListCons '}' { DDat $2 $5 }


Cons :: { Cons }
Cons : IdCon ListPar { FCon $1 (reverse $2) } 


ListCons :: { [Cons] }
ListCons : Cons { (:[]) $1 } 
  | Cons '|' ListCons { (:) $1 $3 }


Par :: { Par }
Par : IdCon { GCon $1 } 


ListPar :: { [Par] }
ListPar : {- empty -} { [] } 
  | ListPar Par { flip (:) $1 $2 }


Arg :: { Arg }
Arg : IdCon { ACon $1 } 
  | IdVar { AVar $1 }
  | '_' { AWild }
  | String { AString $1 }
  | Char { AChar $1 }
  | Integer { AInteger $1 }
  | Double { ADouble $1 }
  | '(' ListBarg ')' { ATuple $2 }


ListArg :: { [Arg] }
ListArg : {- empty -} { [] } 
  | Arg ListArg { (:) $1 $2 }
  | {- empty -} { [] }
  | Arg ListArg { (:) $1 $2 }


Barg :: { Barg }
Barg : IdCon ListArg { BCon $1 $2 } 
  | Arg { BArg $1 }


ListBarg :: { [Barg] }
ListBarg : {- empty -} { [] } 
  | Barg { (:[]) $1 }
  | Barg ',' ListBarg { (:) $1 $3 }


Type :: { Type }
Type : IdCon { TName $1 } 
  | IdVar { TVar $1 }
  | '(' Type '->' ListType ')' { TFun $2 $4 }


ListType :: { [Type] }
ListType : Type { (:[]) $1 } 
  | Type '->' ListType { (:) $1 $3 }


Exp2 :: { Exp }
Exp2 : IdVar { EVar $1 } 
  | IdCon { ECon $1 }
  | '(' IdOpr ')' { EOpr $2 }
  | String { EString $1 }
  | Char { EChar $1 }
  | Integer { EInteger $1 }
  | Double { EDouble $1 }
  | '(' Exp ')' { $2 }


Exp1 :: { Exp }
Exp1 : Exp1 IdOpr Exp2 { EInfix $1 $2 $3 } 
  | Exp1 Exp2 { EApp $1 $2 }
  | 'case' Exp1 'of' '{' ListCla '}' { ECase $2 $5 }
  | 'if' Exp1 'then' Exp2 'else' Exp2 { EIf $2 $4 $6 }
  | Exp2 { $1 }


Exp :: { Exp }
Exp : '\\' ListPat '->' Exp { ELambda $2 $4 } 
  | Exp1 { $1 }


Cla :: { Cla }
Cla : Pat '->' Exp { CClause $1 $3 } 


ListCla :: { [Cla] }
ListCla : Cla { (:[]) $1 } 
  | Cla ';' ListCla { (:) $1 $3 }


Pat :: { Pat }
Pat : IdCon { PCon $1 } 
  | IdVar { PVar $1 }
  | '_' { PWild }
  | String { PString $1 }
  | Char { PChar $1 }
  | Integer { PInteger $1 }
  | Double { PDouble $1 }


ListPat :: { [Pat] }
ListPat : Pat { (:[]) $1 } 
  | Pat ListPat { (:) $1 $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

