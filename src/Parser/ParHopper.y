-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.ParHopper where
import Parser.AbsHopper
import Parser.LexHopper
import Utils.ErrM

}

%name pModule Module

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  '->' { PT _ (TS _ 4) }
  '::' { PT _ (TS _ 5) }
  ';' { PT _ (TS _ 6) }
  '=' { PT _ (TS _ 7) }
  '\\' { PT _ (TS _ 8) }
  '_' { PT _ (TS _ 9) }
  'case' { PT _ (TS _ 10) }
  'data' { PT _ (TS _ 11) }
  'else' { PT _ (TS _ 12) }
  'if' { PT _ (TS _ 13) }
  'module' { PT _ (TS _ 14) }
  'of' { PT _ (TS _ 15) }
  'then' { PT _ (TS _ 16) }
  'where' { PT _ (TS _ 17) }
  '{' { PT _ (TS _ 18) }
  '|' { PT _ (TS _ 19) }
  '}' { PT _ (TS _ 20) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_IdVar { PT _ (T_IdVar $$) }
L_IdCon { PT _ (T_IdCon $$) }
L_IdOpr { PT _ (T_IdOpr $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
IdVar    :: { IdVar} : L_IdVar { IdVar ($1)}
IdCon    :: { IdCon} : L_IdCon { IdCon ($1)}
IdOpr    :: { IdOpr} : L_IdOpr { IdOpr ($1)}

Module :: { Module }
Module : 'module' IdCon Exports 'where' ';' ListDef { MMod $2 $3 $6 } 


Exports :: { Exports }
Exports : {- empty -} { NEmpty } 
  | '(' ListExport ')' { NExps $2 }


Export :: { Export }
Export : IdVar { NExp $1 } 


ListExport :: { [Export] }
ListExport : {- empty -} { [] } 
  | Export { (:[]) $1 }
  | Export ',' ListExport { (:) $1 $3 }


Def :: { Def }
Def : Func { DFun $1 } 
  | Sign { DSig $1 }
  | Adt { DAdt $1 }


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | Def { (:[]) $1 }
  | Def ';' ListDef { (:) $1 $3 }


Func :: { Func }
Func : IdVar ListArg '=' '{' Expr '}' { FFun $1 (reverse $2) $5 } 


Arg :: { Arg }
Arg : Id { AId $1 } 
  | Prim { APrim $1 }
  | '_' { AWild }
  | '(' ListArgTuple ')' { ATuple $2 }


ListArg :: { [Arg] }
ListArg : {- empty -} { [] } 
  | ListArg Arg { flip (:) $1 $2 }


ArgTuple :: { ArgTuple }
ArgTuple : IdCon Arg ListArg { ArCon $1 $2 (reverse $3) } 
  | Arg { ArArg $1 }


ListArgTuple :: { [ArgTuple] }
ListArgTuple : {- empty -} { [] } 
  | ArgTuple { (:[]) $1 }
  | ArgTuple ',' ListArgTuple { (:) $1 $3 }


Expr2 :: { Expr }
Expr2 : Id { EId $1 } 
  | Prim { EPrim $1 }
  | '(' IdOpr ')' { EOpr $2 }
  | '(' Expr ')' { $2 }


Expr1 :: { Expr }
Expr1 : Expr1 IdOpr Expr2 { EInfix $1 $2 $3 } 
  | Expr1 Expr2 { EApp $1 $2 }
  | 'case' Expr1 'of' '{' ListCla '}' { ECase $2 $5 }
  | 'if' Expr1 'then' Expr2 'else' Expr2 { EIf $2 $4 $6 }
  | Expr2 { $1 }


Expr :: { Expr }
Expr : '\\' ListPat '->' Expr { ELambda $2 $4 } 
  | Expr1 { $1 }


Cla :: { Cla }
Cla : Pat '->' Expr { CClause $1 $3 } 


ListCla :: { [Cla] }
ListCla : Cla { (:[]) $1 } 
  | Cla ';' ListCla { (:) $1 $3 }


Pat :: { Pat }
Pat : Id { PId $1 } 
  | Prim { PPrim $1 }
  | '_' { PWild }
  | '(' ListPatTuple ')' { PTuple $2 }


ListPat :: { [Pat] }
ListPat : Pat { (:[]) $1 } 
  | Pat ListPat { (:) $1 $2 }


PatTuple :: { PatTuple }
PatTuple : IdCon Pat ListPat { PaCon $1 $2 $3 } 
  | Pat { PaPat $1 }


ListPatTuple :: { [PatTuple] }
ListPatTuple : {- empty -} { [] } 
  | PatTuple { (:[]) $1 }
  | PatTuple ',' ListPatTuple { (:) $1 $3 }


Sign :: { Sign }
Sign : IdVar '::' '{' ListType '}' { SSig $1 $4 } 


Type :: { Type }
Type : IdCon ListId { TName $1 (reverse $2) } 
  | IdVar ListId { TVar $1 (reverse $2) }
  | '(' ListTypeTuple ')' { TTuple $2 }


ListType :: { [Type] }
ListType : Type { (:[]) $1 } 
  | Type '->' ListType { (:) $1 $3 }


TypeTuple :: { TypeTuple }
TypeTuple : ListType { TyTuple $1 } 


ListTypeTuple :: { [TypeTuple] }
ListTypeTuple : {- empty -} { [] } 
  | TypeTuple { (:[]) $1 }
  | TypeTuple ',' ListTypeTuple { (:) $1 $3 }


Adt :: { Adt }
Adt : 'data' IdCon ListAdtVar '=' '{' ListCons '}' { AAdt $2 (reverse $3) $6 } 


AdtVar :: { AdtVar }
AdtVar : IdVar { AdVar $1 } 


ListAdtVar :: { [AdtVar] }
ListAdtVar : {- empty -} { [] } 
  | ListAdtVar AdtVar { flip (:) $1 $2 }


Cons :: { Cons }
Cons : IdCon ListId { CCon $1 (reverse $2) } 


ListCons :: { [Cons] }
ListCons : Cons { (:[]) $1 } 
  | Cons '|' ListCons { (:) $1 $3 }


Id :: { Id }
Id : IdCon { ICon $1 } 
  | IdVar { IVar $1 }


ListId :: { [Id] }
ListId : {- empty -} { [] } 
  | ListId Id { flip (:) $1 $2 }


Prim :: { Prim }
Prim : Integer { IInteger $1 } 
  | Double { IDouble $1 }
  | String { IString $1 }
  | Char { IChar $1 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

