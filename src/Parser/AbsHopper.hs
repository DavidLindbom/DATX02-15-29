

module Parser.AbsHopper where

-- Haskell module generated by the BNF converter




newtype IdVar = IdVar String deriving (Eq,Ord,Show,Read)
newtype IdCon = IdCon String deriving (Eq,Ord,Show,Read)
newtype IdOpr = IdOpr String deriving (Eq,Ord,Show,Read)
data Module =
   MMod IdCon Exports [Def]
  deriving (Eq,Ord,Show,Read)

data Exports =
   NEmpty
 | NExps [Export]
  deriving (Eq,Ord,Show,Read)

data Export =
   NExp IdVar
  deriving (Eq,Ord,Show,Read)

data Def =
   DFun Func
 | DSig Sign
 | DAdt Adt
  deriving (Eq,Ord,Show,Read)

data Func =
   FFun IdVar [Arg] Expr
  deriving (Eq,Ord,Show,Read)

data Arg =
   AId Id
 | APrim Prim
 | AWild
 | ATuple [ArgTuple]
  deriving (Eq,Ord,Show,Read)

data ArgTuple =
   ArCon IdCon Arg [Arg]
 | ArArg Arg
  deriving (Eq,Ord,Show,Read)

data Expr =
   EId Id
 | EPrim Prim
 | EOpr IdOpr
 | EInfix Expr IdOpr Expr
 | EApp Expr Expr
 | ECase Expr [Cla]
 | EIf Expr Expr Expr
 | ELambda [Pat] Expr
  deriving (Eq,Ord,Show,Read)

data Cla =
   CClause Pat Expr
  deriving (Eq,Ord,Show,Read)

data Pat =
   PId Id
 | PPrim Prim
 | PWild
 | PTuple [PatTuple]
  deriving (Eq,Ord,Show,Read)

data PatTuple =
   PaCon IdCon Pat [Pat]
 | PaPat Pat
  deriving (Eq,Ord,Show,Read)

data Sign =
   SSig IdVar [Type]
  deriving (Eq,Ord,Show,Read)

data Type =
   TName IdCon [Id]
 | TVar IdVar [Id]
 | TTuple [TypeTuple]
  deriving (Eq,Ord,Show,Read)

data TypeTuple =
   TyTuple [Type]
  deriving (Eq,Ord,Show,Read)

data Adt =
   AAdt IdCon [AdtVar] [Cons]
  deriving (Eq,Ord,Show,Read)

data AdtVar =
   AdVar IdVar
  deriving (Eq,Ord,Show,Read)

data Cons =
   CCon IdCon [Id]
  deriving (Eq,Ord,Show,Read)

data Id =
   ICon IdCon
 | IVar IdVar
  deriving (Eq,Ord,Show,Read)

data Prim =
   IInteger Integer
 | IDouble Double
 | IString String
 | IChar Char
  deriving (Eq,Ord,Show,Read)

