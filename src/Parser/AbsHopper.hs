

module Parser.AbsHopper where

-- Haskell module generated by the BNF converter




newtype IdVar = IdVar String deriving (Eq,Ord,Show,Read)
newtype IdCon = IdCon String deriving (Eq,Ord,Show,Read)
newtype IdOpr = IdOpr String deriving (Eq,Ord,Show,Read)
data Module =
   MModule IdCon [Export] [Def]
  deriving (Eq,Ord,Show,Read)

data Export =
   MExport IdVar
  deriving (Eq,Ord,Show,Read)

data Def =
   DSig IdVar [Type]
 | DFun IdVar [Arg] Exp
 | DDat IdCon [Cons]
  deriving (Eq,Ord,Show,Read)

data Cons =
   FCon IdCon [Par]
  deriving (Eq,Ord,Show,Read)

data Par =
   GCon IdCon
  deriving (Eq,Ord,Show,Read)

data Arg =
   ACon IdCon
 | AVar IdVar
 | AWild
 | AString String
 | AChar Char
 | AInteger Integer
 | ADouble Double
 | ATuple [Barg]
  deriving (Eq,Ord,Show,Read)

data Barg =
   BCon IdCon [Arg]
 | BArg Arg
  deriving (Eq,Ord,Show,Read)

data Type =
   TName IdCon
 | TVar IdVar
 | TFun Type [Type]
  deriving (Eq,Ord,Show,Read)

data Exp =
   EVar IdVar
 | ECon IdCon
 | EOpr IdOpr
 | EString String
 | EChar Char
 | EInteger Integer
 | EDouble Double
 | EInfix Exp IdOpr Exp
 | EApp Exp Exp
 | ECase Exp [Cla]
 | EIf Exp Exp Exp
 | ELambda [Pat] Exp
  deriving (Eq,Ord,Show,Read)

data Cla =
   CClause Pat Exp
  deriving (Eq,Ord,Show,Read)

data Pat =
   PCon IdCon
 | PVar IdVar
 | PWild
 | PString String
 | PChar Char
 | PInteger Integer
 | PDouble Double
 | PTuple [Qpat]
  deriving (Eq,Ord,Show,Read)

data Qpat =
   QCon IdCon [Qpat]
 | QPat Pat
  deriving (Eq,Ord,Show,Read)

