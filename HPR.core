module 'HPR' ['and'/2, 'id'/1, 'loop'/1] attributes []
'Cons'/2 =
    fun(X@1, X@2) ->
        case {X@1, X@2} of
            {Px1, Px2} when 'true' ->
                {'HPR.Cons', Px1, Px2}
            ({_cor1} when 'true' ->
                 primop 'match_fail'({'case_clause', _cor1})
             -| ['compiler_generated'])
        end
'__Cons'/0 =
    fun() ->
        apply call 'erlang':'make_fun' ('curry', 'curry', 1)('Cons'/2)
'Nil'/0 =
    fun() ->
        case {} of
            {} when 'true' ->
                'HPR.Nil'
            ({_cor1} when 'true' ->
                 primop 'match_fail'({'case_clause', _cor1})
             -| ['compiler_generated'])
        end
'__Nil'/0 =
    fun() ->
        apply call 'erlang':'make_fun' ('curry', 'curry', 1)('Nil'/0)
'and'/2 =
    fun(X@1, X@2) ->
        case {X@1, X@2} of
            {Px, Py} when 'true' ->
                Px
            ({_cor1} when 'true' ->
                 primop 'match_fail'({'case_clause', _cor1})
             -| ['compiler_generated'])
        end
'__and'/0 =
    fun() ->
        apply call 'erlang':'make_fun' ('curry', 'curry', 1)('and'/2)
'id'/1 =
    fun(X@1) ->
        case {X@1} of
            {Px} when 'true' ->
                Px
            ({_cor1} when 'true' ->
                 primop 'match_fail'({'case_clause', _cor1})
             -| ['compiler_generated'])
        end
'__id'/0 =
    fun() ->
        apply call 'erlang':'make_fun' ('curry', 'curry', 1)('id'/1)
'loop'/1 =
    fun(X@1) ->
        case {X@1} of
            {Px} when 'true' ->
                apply apply '__loop'/0()(Px)
            ({_cor1} when 'true' ->
                 primop 'match_fail'({'case_clause', _cor1})
             -| ['compiler_generated'])
        end
'__loop'/0 =
    fun() ->
        apply call 'erlang':'make_fun' ('curry', 'curry', 1)('loop'/1)
'module_info'/0 =
    fun() -> call 'erlang':'get_module_info' ('HPR')
'module_info'/1 =
    fun(_cor0) -> call 'erlang':'get_module_info' ('HPR', _cor0)
end